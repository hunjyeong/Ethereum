#include <iostream>
#include <openssl/aes.h>
#include <random>
#include <vector>
#include <boost/multiprecision/cpp_int.hpp>

void generate_aes_key_and_iv(unsigned char *key, unsigned char *iv) {
    std::random_device rd;
    std::uniform_int_distribution<unsigned short> dist(0, 255);

    for (int i = 0; i < 32; ++i) {
        key[i] = static_cast<unsigned char>(dist(rd));
    }

    for (int i = 0; i < 16; ++i) {
        iv[i] = static_cast<unsigned char>(dist(rd));
    }
}

boost::multiprecision::uint512_t aes_ctr_random_uint512(unsigned char *key, unsigned char *iv) {
    AES_KEY aes_key;
    if (AES_set_encrypt_key(key, 256, &aes_key) < 0) {
        std::cerr << "Error setting AES encryption key." << std::endl;
        exit(1);
    }

    unsigned char ctr[AES_BLOCK_SIZE];
    memcpy(ctr, iv, AES_BLOCK_SIZE);
    unsigned char ecount_buf[AES_BLOCK_SIZE];
    memset(ecount_buf, 0, AES_BLOCK_SIZE);

    unsigned int num = 0;

    constexpr int num_bytes = 64;
    std::vector<unsigned char> output(num_bytes);
    AES_ctr128_encrypt(output.data(), output.data(), num_bytes, &aes_key, ctr, ecount_buf, &num);

    boost::multiprecision::uint512_t random_value = 0;
    for (int i = 0; i < num_bytes; ++i) {
        random_value <<= 8;
        random_value |= output[i];
    }

    return random_value;
}


//test code
int main() {
    unsigned char key[32];
    unsigned char iv[16];
    generate_aes_key_and_iv(key, iv);

    boost::multiprecision::uint512_t random_value = aes_ctr_random_uint512(key, iv);
    std::cout << "Random uint512_t: " << random_value << std::endl;

    return 0;
}
